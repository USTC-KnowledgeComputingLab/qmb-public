"""
This file contains the Hamiltonian class, which is used to store the Hamiltonian and process iteration over each term in the Hamiltonian for given configurations.
"""

import os
import typing
import torch
import torch.utils.cpp_extension


@torch.jit.script
def _drop_outside(
    index_i: torch.Tensor,
    configs_j: torch.Tensor,
    coefs: torch.Tensor,
    configs_i: torch.Tensor,
) -> tuple[
        torch.Tensor,
        torch.Tensor,
        torch.Tensor,
]:
    """
    Filters out the terms generated by the relative method that do not correspond to any existing configuration in the source.
    """
    device = configs_i.device

    both = torch.cat([configs_i, configs_j], dim=0)
    pool, both_to_pool = torch.unique(both, dim=0, sorted=False, return_inverse=True, return_counts=False)

    src_size = configs_i.size(0)
    pool_size = pool.size(0)

    src_to_pool = both_to_pool[:src_size]
    pool_to_src = torch.full([pool_size], -1, dtype=torch.int64, device=device)
    pool_to_src[src_to_pool] = torch.arange(src_size, device=device)

    dst_to_pool = both_to_pool[src_size:]
    dst_to_src = pool_to_src[dst_to_pool]

    usable = dst_to_src != -1

    return index_i[usable], configs_j[usable], coefs[usable]


@torch.jit.script
def _construct_inside(
    index_i: torch.Tensor,
    configs_j: torch.Tensor,
    coefs: torch.Tensor,
    configs_i: torch.Tensor,
) -> tuple[
        torch.Tensor,
        torch.Tensor,
]:
    device = configs_i.device

    both = torch.cat([configs_i, configs_j], dim=0)
    pool, both_to_pool = torch.unique(both, dim=0, sorted=False, return_inverse=True, return_counts=False)

    src_size = configs_i.shape[0]
    pool_size = pool.shape[0]

    src_to_pool = both_to_pool[:src_size]
    pool_to_src = torch.full([pool_size], -1, dtype=torch.int64, device=device)
    pool_to_src[src_to_pool] = torch.arange(src_size, device=device)

    dst_to_pool = both_to_pool[src_size:]
    dst_to_src = pool_to_src[dst_to_pool]

    return torch.stack([index_i, dst_to_src], dim=1), torch.view_as_complex(coefs)


@torch.jit.script
def _construct_outside(
    index_i: torch.Tensor,
    configs_j: torch.Tensor,
    coefs: torch.Tensor,
    configs_i: torch.Tensor,
) -> tuple[
        torch.Tensor,
        torch.Tensor,
        torch.Tensor,
]:
    device = configs_i.device

    both = torch.cat([configs_i, configs_j], dim=0)
    pool, both_to_pool = torch.unique(both, dim=0, sorted=False, return_inverse=True, return_counts=False)

    src_size = configs_i.shape[0]
    pool_size = pool.shape[0]

    src_to_pool = both_to_pool[:src_size]
    pool_to_target = torch.full([pool_size], -1, dtype=torch.int64, device=device)
    pool_to_target[src_to_pool] = torch.arange(src_size, device=device)
    pool_to_target[pool_to_target == -1] = torch.arange(src_size, pool_size, device=device)

    dst_to_pool = both_to_pool[src_size:]
    dst_to_target = pool_to_target[dst_to_pool]

    target = torch.empty_like(pool)
    target[pool_to_target] = pool

    return torch.stack([index_i, dst_to_target], dim=1), torch.view_as_complex(coefs), target


class Hamiltonian:
    """
    The Hamiltonian type, which stores the Hamiltonian and processes iteration over each term in the Hamiltonian for given configurations.
    """

    _extension: object = None

    @classmethod
    def _get_extension(cls) -> object:
        if cls._extension is None:
            folder = os.path.dirname(__file__)
            cls._extension = torch.utils.cpp_extension.load(
                name="_hamiltonian",
                sources=[
                    f"{folder}/_hamiltonian.cpp",
                    f"{folder}/_hamiltonian_cuda.cu",
                ],
            )
        return cls._extension

    def __init__(self, hamiltonian: dict[tuple[tuple[int, int], ...], complex], *, kind: str) -> None:
        self.site: torch.Tensor
        self.kind: torch.Tensor
        self.coef: torch.Tensor
        self.site, self.kind, self.coef = getattr(self._get_extension(), "prepare")(hamiltonian)
        self._relative_impl: typing.Callable[[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor], tuple[torch.Tensor, torch.Tensor, torch.Tensor]]
        self._relative_impl = getattr(torch.ops._hamiltonian, kind)

    def _prepare_data(self, device: torch.device) -> None:
        self.site = self.site.to(device=device).contiguous()
        self.kind = self.kind.to(device=device).contiguous()
        self.coef = self.coef.to(device=device).contiguous()

    def _relative(
        self,
        configs_i: torch.Tensor,
        *,
        term_group_size: int = 256,
        batch_group_size: int = -1,
        drop_outside: bool = False,
    ) -> tuple[
            torch.Tensor,
            torch.Tensor,
            torch.Tensor,
    ]:
        # pylint: disable=too-many-locals
        batch_size = configs_i.size(0)
        term_number = self.site.size(0)
        if batch_group_size == -1:
            batch_group_size = batch_size
        if term_group_size == -1:
            term_group_size = term_number

        index_i_pool = []
        configs_j_pool = []
        coefs_pool = []

        for i in range(0, term_number, term_group_size):
            for j in range(0, batch_size, batch_group_size):
                index_i, configs_j, coefs = self._relative_impl(
                    configs_i[j:j + batch_group_size],
                    self.site[i:i + term_group_size],
                    self.kind[i:i + term_group_size],
                    self.coef[i:i + term_group_size],
                )
                index_i = index_i + j
                if drop_outside:
                    dropped_index_i, dropped_configs_j, dropped_coefs = _drop_outside(index_i, configs_j, coefs, configs_i)
                    index_i_pool.append(dropped_index_i)
                    configs_j_pool.append(dropped_configs_j)
                    coefs_pool.append(dropped_coefs)
                else:
                    index_i_pool.append(index_i)
                    configs_j_pool.append(configs_j)
                    coefs_pool.append(coefs)

        return torch.cat(index_i_pool, dim=0), torch.cat(configs_j_pool, dim=0), torch.cat(coefs_pool, dim=0)

    def inside(
        self,
        configs_i: torch.Tensor,
    ) -> tuple[
            torch.Tensor,
            torch.Tensor,
    ]:
        """
        Applies the Hamiltonian to the given configuration and obtains the resulting sparse Hamiltonian matrix block within the configuration subspace.
        This function only considers the terms that are within the configuration subspace.

        Parameters
        ----------
        configs_i : torch.Tensor
            A tensor of shape [batch_size, n_qubits] representing the input configurations.

        Returns
        -------
        tuple[torch.Tensor, torch.Tensor]
            A tuple containing two tensors:
                - index_i_and_j: A tensor of shape [..., 2] representing the indices (i, j) for the non-zero Hamiltonian terms.
                - coefs: A tensor of shape [...] representing the corresponding complex coefficients for the indices.
        """
        device: torch.device = configs_i.device
        self._prepare_data(device)
        # Parameters
        # configs_i : bool[src_size, n_qubits]
        # Returns
        # index_i_and_j : int64[..., 2]
        # coefs : complex128[...]

        index_i, configs_j, coefs = self._relative(configs_i, drop_outside=True)
        # configs_i : bool[src_size, n_qubits]
        # index_i : int64[dst_size]
        # configs_j : bool[dst_size, n_qubits]
        # coefs : float64[dst_size, 2]

        return _construct_inside(
            index_i,
            configs_j,
            coefs,
            configs_i,
        )

    def outside(
        self,
        configs_i: torch.Tensor,
    ) -> tuple[
            torch.Tensor,
            torch.Tensor,
            torch.Tensor,
    ]:
        """
        Applies the Hamiltonian to the given configuration and obtains the resulting sparse Hamiltonian matrix block within the configuration subspace.
        This function considers both the inside and outside configurations, ensuring that the input configurations are the first `batch_size` configurations in the result.

        Parameters
        ----------
        configs_i : torch.Tensor
            A tensor of shape [batch_size, n_qubits] representing the input configurations.

        Returns
        -------
        tuple[torch.Tensor, torch.Tensor, torch.Tensor]
            A tuple containing three tensors:
                - index_i_and_j: A tensor of shape [..., 2] representing the indices (i, j) for the non-zero Hamiltonian terms.
                - coefs: A tensor of shape [...] representing the corresponding complex coefficients for the indices.
                - configs_target: A tensor of shape [pool_size, n_qubits] representing the target configurations after processing.
                  The first `batch_size` configurations are guaranteed to be identical to the input `configs_i`.
        """
        device: torch.device = configs_i.device
        self._prepare_data(device)
        # Parameters
        # configs_i : bool[src_size, n_qubits]
        # Returns
        # index_i_and_j : int64[..., 2]
        # coefs : complex128[...]
        # configs_j : bool[dst_size, n_qubits]

        index_i, configs_j, coefs = self._relative(configs_i)
        # configs_i : bool[batch_size, n_qubits]
        # index_i : int64[dst_size]
        # configs_j : bool[dst_size, n_qubits]
        # coefs : float64[dst_size, 2]

        return _construct_outside(
            index_i,
            configs_j,
            coefs,
            configs_i,
        )
